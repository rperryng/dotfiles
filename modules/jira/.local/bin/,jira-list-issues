#!/usr/bin/env bash

set -eo pipefail

JIRA_CACHE_FILE="${XDG_CACHE_HOME:-$HOME/.cache}/jira/issues.txt"
JIRA_JQL_QUERY_FILE="$HOME/.config/.jira/jira_issues_query.jql"

fetch_issues() {
  if [[ ! -f "$JIRA_JQL_QUERY_FILE" ]]; then
    echo "Jira JQL query file not found: $JIRA_JQL_QUERY_FILE" >&2
    return 1
  fi
  local jql_query
  jql_query=$(cat "$JIRA_JQL_QUERY_FILE" | tr -d "\n")

  jira issues list \
    --plain \
    --columns 'type,key,assignee,status,summary'\
    --jql "$(jql_query)"
}

# Fetches new issues and updates the cache.
# Does not print to stdout.
update_cache() {
  local temp_file="${JIRA_CACHE_FILE}.tmp"
  if fetch_issues > "$temp_file"; then
    mkdir -p "$(dirname "$JIRA_CACHE_FILE")"
    mv "$temp_file" "$JIRA_CACHE_FILE"
  else
    echo "Failed to fetch issues" 1>&2
    rm -f "$temp_file"
    return 1
  fi
}

fetch_print_and_cache() {
  local temp_file="${JIRA_CACHE_FILE}.tmp"
  fetch_issues | tee "$temp_file"
  mkdir -p "$(dirname "$JIRA_CACHE_FILE")"
  mv "$temp_file" "$JIRA_CACHE_FILE"
}

main() {
  local use_cache=1
  if [[ "$1" == "--no-cache" ]]; then
    use_cache=0
  fi

  if [[ "$use_cache" -eq 1 ]] && [[ -f "$JIRA_CACHE_FILE" ]]; then
    cat "$JIRA_CACHE_FILE"

    # Update cache in the background.
    # The output is redirected to /dev/null to not interfere with the current shell,
    # e.g. if being used as an input to fzf
    update_cache &>/dev/null &
  else
    # First run, or --no-cache was passed.
    fetch_print_and_cache
  fi
}

main "$@"
